<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Å—Ç–∏–ª–∏ ... */
    </style>
</head>
<body>
    <div class="main-container">
        <!-- –õ–µ–≤–∞—è —á–∞—Å—Ç—å - –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ -->
        <div class="speech-container">
            <h1>–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏</h1>
            <textarea id="output" placeholder="–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç..."></textarea>
            <div class="buttons">
                <button class="toggle" onclick="toggleRecognition()">üé§ –°—Ç–∞—Ä—Ç</button>
                <button class="clear" onclick="clearText()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
                <button class="send-button" onclick="sendToAI()">üì§ –û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
            </div>
            <div class="status" id="status"></div>
        </div>

        <!-- –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å - AI –æ—Ç–≤–µ—Ç—ã -->
        <div class="ai-container">
            <h1>AI –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç</h1>
            <div class="settings-panel">
                <div class="api-status">
                    <span class="status-dot"></span>
                    <span class="status-text">–°—Ç–∞—Ç—É—Å API: –ø—Ä–æ–≤–µ—Ä–∫–∞...</span>
                </div>
                <select id="ai-model" onchange="changeModel()">
                    <option value="gigachat">GigaChat (–°–±–µ—Ä)</option>
                    <option value="openassistant">OpenAssistant (–ë–µ—Å–ø–ª–∞—Ç–Ω–æ)</option>
                    <option value="yandexgpt">Yandex GPT</option>
                    <option value="gpt4all">GPT4All (–õ–æ–∫–∞–ª—å–Ω–æ)</option>
                    <option value="claude">Claude-2</option>
                </select>
                <div class="api-key-input" style="display: none;">
                    <input type="password" id="custom-api-key" placeholder="–í–≤–µ–¥–∏—Ç–µ API –∫–ª—é—á">
                    <button onclick="saveApiKey()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–ª—é—á</button>
                </div>
            </div>
            <div class="chat-container" id="chat"></div>
            <div class="buttons">
                <button class="clear" onclick="clearHistory()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é</button>
            </div>
        </div>
    </div>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏
        let recognition = null;
        let isRecognizing = false;
        
        // API –∫–ª—é—á–∏
        const API_KEYS = {
            gigachat: localStorage.getItem('gigachat_key') || '',
            yandexgpt: localStorage.getItem('yandex_key') || '',
            claude: localStorage.getItem('claude_key') || '',
            openassistant: 'public-free'
        };

        const API_ENDPOINTS = {
            gigachat: '/api/chat',  // –ò–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ –ª–æ–∫–∞–ª—å–Ω—ã–π endpoint
            yandexgpt: 'https://llm.api.cloud.yandex.net/foundationModels/v1/completion',
            claude: 'https://api.anthropic.com/v1/messages',
            openassistant: 'https://api.openassistant.xyz/v1/chat',
            gpt4all: 'http://localhost:4891/v1/chat/completions'
        };

        let currentModel = 'gigachat';  // –ò–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ gigachat –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        let dialogHistory = [];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏
        function initRecognition() {
            if (!('webkitSpeechRecognition' in window)) {
                alert('–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome.');
                return;
            }

            recognition = new webkitSpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'ru-RU';
            
            recognition.onstart = () => {
                updateStatus('–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ. –ì–æ–≤–æ—Ä–∏—Ç–µ...');
                const toggleBtn = document.querySelector('.toggle');
                toggleBtn.textContent = 'üé§ –°—Ç–æ–ø';
                toggleBtn.classList.add('active');
                isRecognizing = true;
            };
            
            recognition.onend = () => {
                updateStatus('–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
                const toggleBtn = document.querySelector('.toggle');
                toggleBtn.textContent = 'üé§ –°—Ç–∞—Ä—Ç';
                toggleBtn.classList.remove('active');
                isRecognizing = false;
            };
            
            recognition.onerror = (event) => {
                updateStatus('–û—à–∏–±–∫–∞: ' + event.error);
                isRecognizing = false;
                const toggleBtn = document.querySelector('.toggle');
                toggleBtn.textContent = 'üé§ –°—Ç–∞—Ä—Ç';
                toggleBtn.classList.remove('active');
            };
            
            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                const output = document.getElementById('output');
                output.value = finalTranscript || interimTranscript;
            };
        }

        // –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è
        function toggleRecognition() {
            if (!recognition) initRecognition();
            if (!recognition) return;
            
            if (!isRecognizing) {
                recognition.start();
            } else {
                recognition.stop();
                updateStatus('–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ');
            }
        }

        // –§—É–Ω–∫—Ü–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –º–æ–¥–µ–ª–∏
        function changeModel() {
            currentModel = document.getElementById('ai-model').value;
            const apiKeyInput = document.querySelector('.api-key-input');
            
            if (['yandexgpt', 'claude'].includes(currentModel)) {
                apiKeyInput.style.display = 'block';
            } else {
                apiKeyInput.style.display = 'none';
            }
            
            if (currentModel === 'gpt4all') {
                checkGPT4AllServer();
            }

            updateApiStatus();
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ API
        async function updateApiStatus() {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-text');
            
            try {
                if (currentModel === 'gigachat' || currentModel === 'openassistant') {
                    statusDot.className = 'status-dot active';
                    statusText.textContent = '–°—Ç–∞—Ç—É—Å API: –î–æ—Å—Ç—É–ø–µ–Ω';
                    return;
                }

                const hasKey = API_KEYS[currentModel] && API_KEYS[currentModel].length > 0;
                if (!hasKey) {
                    statusDot.className = 'status-dot error';
                    statusText.textContent = '–°—Ç–∞—Ç—É—Å API: –¢—Ä–µ–±—É–µ—Ç—Å—è –∫–ª—é—á';
                    return;
                }

                const isValid = await validateApiKey(currentModel, API_KEYS[currentModel]);
                statusDot.className = `status-dot ${isValid ? 'active' : 'error'}`;
                statusText.textContent = `–°—Ç–∞—Ç—É—Å API: ${isValid ? '–î–æ—Å—Ç—É–ø–µ–Ω' : '–û—à–∏–±–∫–∞'}`;
            } catch (error) {
                statusDot.className = 'status-dot error';
                statusText.textContent = '–°—Ç–∞—Ç—É—Å API: –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è';
            }
        }

        // –í–∞–ª–∏–¥–∞—Ü–∏—è API –∫–ª—é—á–µ–π
        async function validateApiKey(model, key) {
            try {
                let isValid = false;
                switch(model) {
                    case 'yandexgpt':
                        const yandexResponse = await fetch(API_ENDPOINTS.yandexgpt, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Api-Key ${key}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                modelUri: "gpt://yandexgpt-lite",
                                completionOptions: {
                                    stream: false,
                                    temperature: 0.6,
                                    maxTokens: "1"
                                },
                                messages: [{ role: "user", text: "test" }]
                            })
                        });
                        isValid = yandexResponse.ok;
                        break;

                    case 'claude':
                        const claudeResponse = await fetch(API_ENDPOINTS.claude, {
                            method: 'POST',
                            headers: {
                                'x-api-key': key,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                messages: [{ role: "user", content: "test" }],
                                model: "claude-2",
                                max_tokens: 1
                            })
                        });
                        isValid = claudeResponse.ok;
                        break;
                }
                return isValid;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∫–ª—é—á–∞:', error);
                return false;
            }
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ API –∫–ª—é—á–∞
        async function saveApiKey() {
            const key = document.getElementById('custom-api-key').value;
            if (!key) {
                alert('–í–≤–µ–¥–∏—Ç–µ API –∫–ª—é—á');
                return;
            }

            const isValid = await validateApiKey(currentModel, key);
            if (isValid) {
                localStorage.setItem(`${currentModel}_key`, key);
                API_KEYS[currentModel] = key;
                alert('API –∫–ª—é—á —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∏ –ø—Ä–æ–≤–µ—Ä–µ–Ω!');
                updateApiStatus();
            } else {
                alert('–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á –∏–ª–∏ –æ—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏');
            }
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ GPT4All
        async function checkGPT4AllServer() {
            try {
                const response = await fetch('http://localhost:4891/health');
                if (!response.ok) throw new Error('GPT4All —Å–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
                updateStatus('GPT4All —Å–µ—Ä–≤–µ—Ä –¥–æ—Å—Ç—É–ø–µ–Ω');
            } catch (error) {
                updateStatus('–û—à–∏–±–∫–∞: GPT4All —Å–µ—Ä–≤–µ—Ä –Ω–µ –∑–∞–ø—É—â–µ–Ω. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä.');
            }
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // –û—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞
        function clearText() {
            document.getElementById('output').value = '';
            updateStatus('');
        }

        // –û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏
        function clearHistory() {
            dialogHistory = [];
            document.getElementById('chat').innerHTML = '';
            localStorage.removeItem('dialogHistory');
        }

        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç
        function addMessage(text, type) {
            const chat = document.getElementById('chat');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            const textDiv = document.createElement('div');
            textDiv.textContent = text;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = new Date().toLocaleTimeString();
            
            messageDiv.appendChild(textDiv);
            messageDiv.appendChild(timeDiv);
            chat.appendChild(messageDiv);
            chat.scrollTop = chat.scrollHeight;

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
            dialogHistory.push({ text, type, time: new Date().toISOString() });
            saveHistory();
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏
        function saveHistory() {
            localStorage.setItem('dialogHistory', JSON.stringify(dialogHistory));
        }

        // –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏
        function loadHistory() {
            const saved = localStorage.getItem('dialogHistory');
            if (saved) {
                dialogHistory = JSON.parse(saved);
                dialogHistory.forEach(msg => {
                    const chat = document.getElementById('chat');
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${msg.type}-message`;
                    
                    const textDiv = document.createElement('div');
                    textDiv.textContent = msg.text;
                    
                    const timeDiv = document.createElement('div');
                    timeDiv.className = 'message-time';
                    timeDiv.textContent = new Date(msg.time).toLocaleTimeString();
                    
                    messageDiv.appendChild(textDiv);
                    messageDiv.appendChild(timeDiv);
                    chat.appendChild(messageDiv);
                });
            }
        }

        // –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ AI
        async function sendToAI() {
            const text = document.getElementById('output').value;
            if (!text) return;

            addMessage(text, 'user');
            
            const aiContainer = document.querySelector('.ai-container');
            aiContainer.classList.add('loading');

            try {
                let response;
                switch(currentModel) {
                    case 'gigachat':
                        response = await callGigaChat(text);
                        break;
                    case 'openassistant':
                        response = await callOpenAssistant(text);
                        break;
                    case 'yandexgpt':
                        response = await callYandexGPT(text);
                        break;
                    case 'gpt4all':
                        response = await callGPT4All(text);
                        break;
                    case 'claude':
                        response = await callClaude(text);
                        break;
                    default:
                        throw new Error('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –º–æ–¥–µ–ª—å');
                }
                addMessage(response, 'ai');
            } catch (error) {
                console.error('Error:', error);
                addMessage(`–û—à–∏–±–∫–∞: ${error.message}`, 'error');
            } finally {
                aiContainer.classList.remove('loading');
            }
        }

        // –§—É–Ω–∫—Ü–∏–∏ –≤—ã–∑–æ–≤–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö API
        async function callGigaChat(text) {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: text
                })
            });

            if (!response.ok) throw new Error(`GigaChat API Error: ${response.status}`);
            const data = await response.json();
            return data.response;
        }

        async function callYandexGPT(text) {
            if (!API_KEYS.yandexgpt) throw new Error('–¢—Ä–µ–±—É–µ—Ç—Å—è API –∫–ª—é—á –¥–ª—è YandexGPT');
            
            const response = await fetch(API_ENDPOINTS.yandexgpt, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Api-Key ${API_KEYS.yandexgpt}`
                },
                body: JSON.stringify({
                    modelUri: `gpt://yandexgpt-lite`,
                    completionOptions: {
                        stream: false,
                        temperature: 0.6,
                        maxTokens: "2000"
                    },
                    messages: [{ role: "user", text: text }]
                })
            });

            if (!response.ok) throw new Error(`YandexGPT API Error: ${response.status}`);
            const data = await response.json();
            return data.result.alternatives[0].message.text;
        }

        async function callGPT4All(text) {
            const response = await fetch(API_ENDPOINTS.gpt4all, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    messages: [{ role: "user", content: text }],
                    temperature: 0.7,
                    max_tokens: 1000
                })
            });

            if (!response.ok) throw new Error(`GPT4All Error: ${response.status}`);
            const data = await response.json();
            return data.choices[0].message.content;
        }

        async function callClaude(text) {
            if (!API_KEYS.claude) throw new Error('–¢—Ä–µ–±—É–µ—Ç—Å—è API –∫–ª—é—á –¥–ª—è Claude-2');
            
            const response = await fetch(API_ENDPOINTS.claude, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': API_KEYS.claude,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    messages: [{ role: "user", content: text }],
                    model: "claude-2",
                    max_tokens: 1000
                })
            });

            if (!response.ok) throw new Error(`Claude API Error: ${response.status}`);
            const data = await response.json();
            return data.content[0].text;
        }

        async function callOpenAssistant(text) {
            const response = await fetch(API_ENDPOINTS.openassistant, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    messages: [{ role: "user", content: text }]
                })
            });

            if (!response.ok) throw new Error(`OpenAssistant Error: ${response.status}`);
            const data = await response.json();
            return data.choices[0].message.content;
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        document.addEventListener('DOMContentLoaded', () => {
            initRecognition();
            loadHistory();
            updateApiStatus();
        });
    </script>
</body>
</html>
